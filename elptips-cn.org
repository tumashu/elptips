#+TITLE: Emacs-lisp Packaging Tips
* 谁应该读这个文档
刚刚从写 Emacs configure 转到写 emacs package 的同学建议读一下
这个文档。
* Configure 和 package 有什么区别
从 Emacs-lisp 语言角度来说，两者没有多大的区别，可能写 package 的时候，
Emacs-lisp 语言应用的更加规范一点。

但编写 configure 和编写 package 需要遵循的理念有很大的不同：
1. Configure 是写给自己用的，如果其他同学使用你的 configure 出了问题，
   那么他只能自认倒霉，你可以不负任何责任。
2. Package 编写出来主要是给其他人使用的，如果出了问题，维护者是有直接
   责任的:-)

* package 编写原则
1. 成本效益原则：
   1. 编写的 package 不能含有恶意代码，不能窃取用户隐私。
   2. 编写的 package 值得用户花时间和精力去学习使用，谨慎的重复制造轮子。
2. 正确使用 Emacs-lisp
3. 尊重社区惯例原则：主要是使用公认的代码缩进方式，让代码容易维护等。
4. 尊重用户选择原则：
   1. 不能随意覆盖自己的用户接口变量
   2. 不能随意覆盖其他 package 的任何全局变量，
      包含用户接口变量和内部使用全局变量。

* 花一些时间给 package 取一个好名字。
Emacs-lisp 和其他 lisp 不同，Emacs-lisp 的全局变量的作用范围非常大，
只要一个 package 加载了，那么在任何地方，都可以访问和设置这个 package
的所有全局变量。

为了防止变量冲突， Emacs 社区有这么一个惯例： 一个 package 的
全局变量，函数定义以及宏定义等，都应该使用统一的前缀，比如：
company 使用 "company-" 前缀。

另外三条建议是：
1. package 不能取其他 package 正在使用或者曾经使用过的名字。
2. package 的名字要好记好写好认，最好是 *一个* 单词或者 *一个* 缩写，
   比如：company, elpa 。
3. package 使用的前缀最好就是 package 的名字。

* 定义变量的正确方式
Emacs-lisp 有许多定义变量的方法，但下面几种是最最常用的。

1. 定义一个用户接口变量
   #+BEGIN_SRC emacs-lisp
   (defcustom elptips-name "elptips-name"
     "Elptips's name.")
   #+END_SRC

   不过值得注意的是：许多人都使用下面的方式偷懒:-)

   #+BEGIN_SRC emacs-lisp
   (defvar elptips-name "elptips-name"
     "Elptips's name.")
   #+END_SRC
2. 定义一个 package *内部使用* 的全局变量
   #+BEGIN_SRC emacs-lisp
   (defvar elptips-name "elptips--name"
     "Elptips's name.")
   #+END_SRC
   注：Lisp 有一个惯例：使用 "-\-" 来表示这个全局变量是包内部
   使用的变量，用户不应该使用它，package 的维护着可以随意对其
   赋值，并且没有义务在升级时维护它的向后兼容性。
3. 定义一个局部变量
   #+BEGIN_SRC emacs-lisp
   (let ((a 1)
         (b 2)
         c)
     (+ a b))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
   (let* ((a 1)
          (b 2)
          (c (+ a b)))
     c)
   #+END_SRC

* 变量赋值的正确方式
简单来说，变量必须先被定义，才能对其赋值。

可惜的是：这个规则非常简单，但新手往往不太注意。

在 Emacs-lisp 中，最常用的变量赋值操作符是：setq,
在一个 package 中，一般只能出现下面 *两种* setq 赋值结构：
1. 对一个 package *内部使用* 的全局变量进行赋值：
   #+BEGIN_SRC emacs-lisp
   (defvar elptips--name "elptips-name"
     "Elptips's name.")
   (setq elptips--name "elptips-name2")
   #+END_SRC
2. 对一个局部变量进行赋值：
   #+BEGIN_SRC emacs-lisp
   (let ((a 1)
         (b 2)
         c)
     (setq c (+ a b)))
   #+END_SRC

其他形式的 setq 赋值结构都是有问题的：

1. 在 package 中对一个用户接口变量进行赋值

   #+BEGIN_SRC emacs-lisp
   (defcustom elptips-name "elptips-name"
     "Elptips's name.")
   (setq elptips-name "elptips-name2")
   #+END_SRC

   无论这个用户接口变量属于自己 package 还是其他 package，都不应该
   这么做，因为它直接违反了 “尊重用户选择” 原则，在一定条件下，加载
   package 会覆盖用户的设置，比如：

   #+BEGIN_SRC emacs-lisp
   (setq elptips-name "elptips-name3")
   (require 'elptips)
   #+END_SRC
2. 不能直接使用 setq 来定义变量

   setq 是变量赋值操作符，但如果被赋值的变量不存在，它会首先定义这个 *全局变量*,
   然后再赋值，下面两个例子是等价的：

   #+BEGIN_SRC emacs-lisp
   (setq elptips-name "elptips-name2")
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
   (defvar elptips-name nil) ;这个全局变量会被用户当成用户接口变量
   (setq elptips-name "elptips-name2")
   #+END_SRC

   编写 configure 的时候，我们可以这样用，但编写 package 的时候，再
   这么用就有问题了。

3. 对一个没有定义的 *局部变量* 赋值

   #+BEGIN_SRC emacs-lisp
   (let ((a 1)
         (b 2))
     (setq c (+ a b)))
   #+END_SRC

   这个例子本质是定义并赋值了一个 *全局变量* c, 正确的写法是：

   #+BEGIN_SRC emacs-lisp
   (let ((a 1)
         (b 2)
         c) ; c 不能遗漏
     (setq c (+ a b)))
   #+END_SRC

   由于这种方式很容易出现遗漏，而且出现的问题严重（容易覆盖 Emacs-lisp
   核心使用的全局变量），所以建议使用 let* 来处理类似情况：

   #+BEGIN_SRC emacs-lisp
   (let* ((a 1)
          (b 2)
          (c (+ a b)))
     c)
   #+END_SRC

* 对变量赋值的再思考
通过 “变量赋值的正确方式” 的讨论，我们可以发现，在编写 package 的
时候，setq 最合理的使用方式只有 *一种* , 即：对 package 内部保留的
全局变量再赋值：

#+BEGIN_SRC emacs-lisp
(defvar elptips--name "elptips-name"
  "Elptips's name.")
(setq elptips--name "elptips-name2")
#+END_SRC

对 *局部变量* 赋值时要慎用 setq, 优先考虑使用 let* , 如果必须使用 setq
对一个局部变量赋值，一定要确保这个局部变量已经在 let 结构中定义了。

在其他情况使用 setq 可能就是滥用了，当然我这里只是说 *可能*, 只要你的
使用方式尊重 package 编写原则，那就是合理的用法 :-)
* 未完待续。。。
* 尾注

# Local Variables:
# coding: utf-8-unix
# End:
